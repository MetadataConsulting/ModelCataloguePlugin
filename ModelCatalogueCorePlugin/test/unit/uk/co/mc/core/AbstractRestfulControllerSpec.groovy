package uk.co.mc.core

import grails.converters.JSON
import grails.util.GrailsNameUtils
import groovy.util.slurpersupport.GPathResult
import groovy.xml.XmlUtil
import org.codehaus.groovy.grails.plugins.web.mimes.MimeTypesFactoryBean
import org.codehaus.groovy.grails.web.json.JSONElement
import spock.lang.Specification
import spock.lang.Unroll
import uk.co.mc.core.fixtures.MockFixturesLoader
import uk.co.mc.core.util.marshalling.AbstractMarshallers

import javax.servlet.http.HttpServletResponse

/**
 * Abstract parent for restful controllers specification.
 *
 * The concrete subclass must use {@link grails.test.mixin.web.ControllerUnitTestMixin}.
 */
abstract class AbstractRestfulControllerSpec<T> extends Specification {

    private static final int DUMMY_ENTITIES_COUNT = 12


    MockFixturesLoader fixturesLoader = new MockFixturesLoader()

    def setup() {
        setupMimeTypes()
        marshallers.each { it.register() }
    }

    protected void setupMimeTypes() {
        def ga = grailsApplication
        ga.config.grails.mime.types =
                [html: ['text/html', 'application/xhtml+xml'],
                        xml: ['text/xml', 'application/xml'],
                        text: 'text/plain',
                        js: 'text/javascript',
                        rss: 'application/rss+xml',
                        atom: 'application/atom+xml',
                        css: 'text/css',
                        csv: 'text/csv',
                        all: '*/*',
                        json: ['application/json', 'text/json'],
                        form: 'application/x-www-form-urlencoded',
                        multipartForm: 'multipart/form-data'
                ]

        defineBeans {
            mimeTypes(MimeTypesFactoryBean) {
                grailsApplication = ga
            }
        }
    }

    /**
     * Records the given json as fixture returning the file created or updated.
     *
     * The json will be available as <code>fixtures.resourceName.fixtureName</code> variable.
     *
     * @param fixtureName name of the fixture variable and the file holding it as well
     * @param json json to be saved to the fixture
     */
    protected File recordResult(String fixtureName, JSONElement json) {
        File fixtureFile = new File("../ModelCatalogueCorePlugin/test/js/modelcatalogue/core/$controller.resourceName/${fixtureName}.gen.fixture.js")
        fixtureFile.parentFile.mkdirs()
        fixtureFile.text = """/** Generated automatically from ${getClass()}. Do not edit this file manually! */
(function (window) {
    window['fixtures'] = window['fixtures'] || {};
    var fixtures = window['fixtures']
    fixtures['$controller.resourceName'] = fixtures['$controller.resourceName'] || {};
    var $controller.resourceName = fixtures['$controller.resourceName']

    window.fixtures.${controller.resourceName}.$fixtureName = ${new JSON(json).toString(true)}

})(window)"""
        println "New fixture file created at $fixtureFile.canonicalPath"
        fixtureFile
    }

    /**
     * Records the given xml text as fixture returning the file created or updated.
     *
     * @param fixtureName name of the fixture variable and the file holding it as well
     * @param xml xml to be saved to the fixture
     */
    protected File recordResult(String fixtureName, GPathResult xml) {
        File fixtureFile = new File("../ModelCatalogueCorePlugin/target/xml-samples/modelcatalogue/core/$controller.resourceName/${fixtureName}.gen.xml")
        fixtureFile.parentFile.mkdirs()
        fixtureFile.text = """${
            XmlUtil.serialize(xml).replace("<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
        }"""
        println "New xml file created at $fixtureFile.canonicalPath"
        fixtureFile
    }


    @Unroll
    def "list items test: #no where max: #max offset: #offset"() {
        fillWithDummyEntities()

        expect:
        resource.count() == total


        when:
        response.format = "json"
        params.max = max
        params.offset = offset

        controller.index()
        JSONElement json = response.json


        recordResult "list${no}", json

        then:

        json.success
        json.size == size
        json.total == total
        json.list
        json.list.size() == size
        json.next == next
        json.previous == previous



        where:

        no | size | max | offset | total | next                                 | previous
        1  | 10   | 10  | 0      | 12    | "/${resourceName}/?max=10&offset=10" | ""
        2  | 5    | 5   | 0      | 12    | "/${resourceName}/?max=5&offset=5"   | ""
        3  | 5    | 5   | 5      | 12    | "/${resourceName}/?max=5&offset=10"  | "/${resourceName}/?max=5&offset=0"
        4  | 4    | 4   | 8      | 12    | ""                                   | "/${resourceName}/?max=4&offset=4"
        5  | 2    | 10  | 10     | 12    | ""                                   | "/${resourceName}/?max=10&offset=0"
        6  | 2    | 2   | 10     | 12    | ""                                   | "/${resourceName}/?max=2&offset=8"

    }

    String getResourceName() {
        GrailsNameUtils.getLogicalPropertyName(getClass().getSimpleName(), "ControllerSpec")
    }

    def "Return 404 for non-existing item as JSON"() {
        response.format = "json"

        params.id = "1000000"

        controller.show()

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }

    def "Return 404 for non-existing item as XML"() {
        response.format = "xml"

        params.id = "1000000"

        controller.show()

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }

    def "Return 404 for non-existing item as JSON for incoming relationships"() {
        response.format = "json"

        params.id = "1000000"

        controller.incoming(10)

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }

    def "Return 404 for non-existing item as XML for incoming relationships"() {
        response.format = "xml"

        params.id = "1000000"

        controller.incoming(10)

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }

    def "Return 404 for non-existing item as JSON for outgoing relationships"() {
        response.format = "json"

        params.id = "1000000"

        controller.outgoing(10)

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }

    def "Return 404 for non-existing item as XML for outgoing relationships"() {
        response.format = "xml"

        params.id = "1000000"

        controller.outgoing(10)

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }

    def "Return 404 for non-existing item as JSON on delete"() {
        response.format = "json"

        params.id = "1000000"

        controller.delete()

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }

    def "Return 404 for non-existing item as XML on delete"() {
        response.format = "xml"

        params.id = "1000000"

        controller.delete()

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NOT_FOUND
    }


    def "Return 204 for existing item as JSON on delete"() {
        response.format = "json"

        params.id = "1"

        controller.delete()

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NO_CONTENT
        !resource.get(params.id)
    }

    def "Return 204 for existing item as XML on delete"() {
        response.format = "xml"

        params.id = "1"

        controller.delete()

        expect:
        response.text == ""
        response.status == HttpServletResponse.SC_NO_CONTENT
        !resource.get(params.id)
    }


    def cleanup() {
        resource.deleteAll(resource.list())
    }

    void fillWithDummyEntities(int limit = DUMMY_ENTITIES_COUNT) {
        (resource.count() + 1).upto(limit) {
            assert resource.newInstance(getUniqueDummyConstructorArgs(it)).save()
        }
    }

    Map<String, Object> getUniqueDummyConstructorArgs(int counter) {
        [name: "$resourceName $counter"]
    }

    List<AbstractMarshallers> getMarshallers() { [] }

    abstract Class<T> getResource()

    // Following needs to be copied to subclasses. Grails mocking framework is not yet capable of handling such
    // level of abstraction

    /*

    @Unroll
    def "get outgoing relationships pagination: #no where max: #max offset: #offset"() {
        fixturesLoader.load('relationshipTypes/RT_relationship')
        RelationshipType relationshipType = fixturesLoader.RT_relationship.save() ?: RelationshipType.findByName('relationship')
        fillWithDummyEntities(15)

        expect:
        relationshipType

        when:

        def first = resource.get(1)

        first.outgoingRelationships = first.outgoingRelationships ?: []

        for (unit in resource.list()) {
            if (unit != first) {
                assert !Relationship.link(first, unit, relationshipType).hasErrors()
                if (first.outgoingRelationships.size() == 12) {
                    break
                }
            }
        }

        then:
        first.outgoingRelationships
        first.outgoingRelationships.size() == 12

        when:
        response.format = "json"
        params.offset = offset
        params.id = first.id

        controller.outgoing(max)
        JSONElement json = response.json


        recordResult "outgoing${no}", json

        then:

        json.success
        json.total == total
        json.size == size
        json.list
        json.list.size() == size
        json.next == next
        json.previous == previous

        cleanup:
        relationshipType?.delete()

        where:
        no | size | max | offset | total | next                                                       | previous
        1  | 10   | 10  | 0      | 12    | "/${resourceName}/outgoing/1?max=10&offset=10" | ""
        2  | 5    | 5   | 0      | 12    | "/${resourceName}/outgoing/1?max=5&offset=5"   | ""
        3  | 5    | 5   | 5      | 12    | "/${resourceName}/outgoing/1?max=5&offset=10"  | "/${resourceName}/outgoing/1?max=5&offset=0"
        4  | 4    | 4   | 8      | 12    | ""                                             | "/${resourceName}/outgoing/1?max=4&offset=4"
        5  | 2    | 10  | 10     | 12    | ""                                             | "/${resourceName}/outgoing/1?max=10&offset=0"
        6  | 2    | 2   | 10     | 12    | ""                                             | "/${resourceName}/outgoing/1?max=2&offset=8"
    }

    @Unroll
    def "get incoming relationships pagination: #no where max: #max offset: #offset"() {
        fixturesLoader.load('relationshipTypes/RT_relationship')
        RelationshipType relationshipType = fixturesLoader.RT_relationship.save() ?: RelationshipType.findByName('relationship')
        fillWithDummyEntities(15)

        expect:
        relationshipType

        when:
        def first = resource.get(1)
        first.incomingRelationships = first.incomingRelationships ?: []

        for (unit in  resource.list()) {
            if (unit != first) {
                assert !Relationship.link(unit, first, relationshipType).hasErrors()
                if (first.incomingRelationships.size() == 12) {
                    break
                }
            }
        }

        then:
        first.incomingRelationships
        first.incomingRelationships.size() == 12

        when:
        response.format = "json"
        params.offset = offset
        params.id = first.id

        controller.incoming(max)
        JSONElement json = response.json


        recordResult "incoming${no}", json

        then:

        json.success
        json.total == total
        json.size == size
        json.list
        json.list.size() == size
        json.next == next
        json.previous == previous

        cleanup:
        relationshipType?.delete()

        where:
        no | size | max | offset | total | next                                                       | previous
        1  | 10   | 10  | 0      | 12    | "/${resourceName}/incoming/1?max=10&offset=10" | ""
        2  | 5    | 5   | 0      | 12    | "/${resourceName}/incoming/1?max=5&offset=5"   | ""
        3  | 5    | 5   | 5      | 12    | "/${resourceName}/incoming/1?max=5&offset=10"  | "/${resourceName}/incoming/1?max=5&offset=0"
        4  | 4    | 4   | 8      | 12    | ""                                             | "/${resourceName}/incoming/1?max=4&offset=4"
        5  | 2    | 10  | 10     | 12    | ""                                             | "/${resourceName}/incoming/1?max=10&offset=0"
        6  | 2    | 2   | 10     | 12    | ""                                             | "/${resourceName}/incoming/1?max=2&offset=8"
    }


     */

}
